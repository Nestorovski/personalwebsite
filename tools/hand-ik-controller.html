<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand IK Controller</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .terminal {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            padding: 1rem;
            border-radius: 8px;
            height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .terminal::-webkit-scrollbar {
            width: 8px;
        }
        .terminal::-webkit-scrollbar-track {
            background: #333;
        }
        .terminal::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 4px;
        }
        .dark .terminal {
            background: #1a1a1a;
        }
        /* Canvas is flipped in the JS logic by drawing the mirrored image, so no CSS transform needed here if that's the case */
        /* canvas { transform: scaleX(-1); } */
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
    <div class="container mx-auto p-4 max-w-6xl">
        <h1 class="text-3xl font-bold mb-6 text-center">Hand IK Controller</h1>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Video and Controls -->
            <div class="space-y-4">
                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4">
                    <h2 class="text-xl font-semibold mb-4">Camera Feed</h2>
                    <div class="relative">
                        <video id="input_video" class="w-full rounded-lg hidden" style="transform: scaleX(-1);"></video>
                        <canvas id="output_canvas" class="w-full rounded-lg border-2 border-gray-300 dark:border-gray-600"></canvas>
                    </div>
                    <div class="mt-4 flex flex-wrap gap-2">
                        <button id="startBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg">
                            Start Camera
                        </button>
                        <button id="stopBtn" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg" disabled>
                            Stop Camera
                        </button>
                        <button id="clearTerminal" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-lg">
                            Clear Terminal
                        </button>
                    </div>
                </div>

                <!-- Configuration -->
                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4">
                    <h3 class="text-lg font-semibold mb-3">Configuration</h3>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="updateRate" class="block text-sm font-medium mb-1">Update Rate (ms)</label>
                            <input type="number" id="updateRate" value="100" min="50" max="1000"
                                   class="w-full p-2 border rounded-lg dark:bg-gray-700 dark:border-gray-600">
                        </div>
                        <div>
                            <label for="angleThreshold" class="block text-sm font-medium mb-1">Angle Threshold (°)</label>
                            <input type="number" id="angleThreshold" value="5" min="1" max="30"
                                   class="w-full p-2 border rounded-lg dark:bg-gray-700 dark:border-gray-600">
                        </div>
                    </div>
                    <div class="mt-3">
                        <label class="flex items-center">
                            <input type="checkbox" id="enableIK" checked
                                   class="mr-2 w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                            <span>Enable IK Commands</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Terminal Output -->
            <div class="space-y-4">
                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4">
                    <h2 class="text-xl font-semibold mb-4">Terminal Output</h2>
                    <div id="terminal" class="terminal"></div>
                </div>

                <!-- Status -->
                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4">
                    <h3 class="text-lg font-semibold mb-3">Status</h3>
                    <div class="space-y-2 text-sm">
                        <div>Camera: <span id="cameraStatus" class="font-mono text-red-500">Disconnected</span></div>
                        <div>Hands Detected: <span id="handsCount" class="font-mono">0</span></div>
                        <div>Last Update: <span id="lastUpdate" class="font-mono">Never</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Help Section -->
        <div class="mt-8 bg-blue-50 dark:bg-blue-900/20 rounded-lg p-4">
            <h3 class="text-lg font-semibold mb-2">How to Use</h3>
            <ul class="list-disc list-inside space-y-1 text-sm">
                <li>Click "Start Camera" to begin hand tracking. Allow camera permissions if prompted.</li>
                <li>Position your hand in front of the camera.</li>
                <li>The terminal will output joint angles and IK commands based on your hand movements.</li>
                <li>Commands format: <code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">JOINT_NAME angle_value</code></li>
                <li>Adjust "Update Rate" and "Angle Threshold" to control sensitivity and output frequency.</li>
                <li>Toggle "Enable IK Commands" to turn on/off the generation of robot-specific commands.</li>
                <li>Use these commands in your robotics control system.</li>
            </ul>
        </div>
    </div>

    <script>
        // Dark mode support based on OS preference
        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
        // Optional: Add a button to toggle dark mode manually and save preference
        // window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => { ... }); // This is fine for OS sync

        class HandIKController {
            constructor() {
                this.video = document.getElementById('input_video');
                this.canvas = document.getElementById('output_canvas');
                this.ctx = this.canvas.getContext('2d');
                this.terminal = document.getElementById('terminal');

                this.hands = null;
                this.camera = null;
                this.isRunning = false;
                this.lastAngles = {}; // Stores last angles per hand and joint
                this.lastUpdateTime = null;

                // Landmark names for clarity (from MediaPipe Hands documentation)
                this.LANDMARK_NAMES = [
                    'WRIST', 'THUMB_CMC', 'THUMB_MCP', 'THUMB_IP', 'THUMB_TIP',
                    'INDEX_FINGER_MCP', 'INDEX_FINGER_PIP', 'INDEX_FINGER_DIP', 'INDEX_FINGER_TIP',
                    'MIDDLE_FINGER_MCP', 'MIDDLE_FINGER_PIP', 'MIDDLE_FINGER_DIP', 'MIDDLE_FINGER_TIP',
                    'RING_FINGER_MCP', 'RING_FINGER_PIP', 'RING_FINGER_DIP', 'RING_FINGER_TIP',
                    'PINKY_MCP', 'PINKY_PIP', 'PINKY_DIP', 'PINKY_TIP'
                ];

                this.initializeMediaPipe();
                this.setupEventListeners();
                this.updateStatus();
                this.printToTerminal('SYSTEM: Hand IK Controller initialized. Click "Start Camera".');
            }

            initializeMediaPipe() {
                this.hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });

                this.hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1, // 0 for lite, 1 for full
                    minDetectionConfidence: 0.6, // Increased slightly
                    minTrackingConfidence: 0.6  // Increased slightly
                });

                this.hands.onResults(this.onResults.bind(this));
            }

            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.startCamera());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopCamera());
                document.getElementById('clearTerminal').addEventListener('click', () => this.clearTerminal());
            }

            async startCamera() {
                if (this.isRunning) return;
                this.printToTerminal('SYSTEM: Starting camera...');
                try {
                    this.camera = new Camera(this.video, {
                        onFrame: async () => {
                            if (this.video.readyState >= 3) { // HAVE_FUTURE_DATA or more
                                await this.hands.send({image: this.video});
                            }
                        },
                        width: 640, // Desired width
                        height: 480 // Desired height
                    });

                    await this.camera.start();
                    this.isRunning = true;

                    // Make video visible to see what mediapipe sees (optional, can be hidden)
                    // this.video.classList.remove('hidden');

                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('cameraStatus').textContent = 'Connected';
                    document.getElementById('cameraStatus').className = 'font-mono text-green-500';

                    this.printToTerminal('SYSTEM: Camera started successfully.');
                    this.printToTerminal('SYSTEM: Hand tracking active.');

                } catch (error) {
                    this.printToTerminal(`ERROR: Failed to start camera: ${error.message}`);
                    if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
                         this.printToTerminal("ERROR: No camera found. Please ensure a camera is connected and enabled.");
                    } else if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
                         this.printToTerminal("ERROR: Camera access denied. Please allow camera permissions in your browser.");
                    }
                    console.error('Camera error:', error);
                    // Re-enable start button if failed
                    document.getElementById('startBtn').disabled = false;
                }
            }

            stopCamera() {
                if (!this.isRunning || !this.camera) return;

                this.camera.stop(); // This will also stop the onFrame loop
                this.camera = null;
                this.isRunning = false;

                // this.video.classList.add('hidden');
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // Clear canvas

                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('cameraStatus').textContent = 'Disconnected';
                document.getElementById('cameraStatus').className = 'font-mono text-red-500';
                document.getElementById('handsCount').textContent = '0';

                this.printToTerminal('SYSTEM: Camera stopped.');
            }

            onResults(results) {
                if (!this.isRunning) return;

                // Set canvas dimensions once based on video, then scale drawing
                if (this.canvas.width !== this.video.videoWidth || this.canvas.height !== this.video.videoHeight) {
                    this.canvas.width = this.video.videoWidth;
                    this.canvas.height = this.video.videoHeight;
                }

                this.ctx.save();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw the camera image mirrored (as the video element itself is not mirrored by default)
                this.ctx.translate(this.canvas.width, 0);
                this.ctx.scale(-1, 1);
                this.ctx.drawImage(results.image, 0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore(); // Restore context for drawing landmarks correctly (not mirrored)

                document.getElementById('handsCount').textContent = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                        const landmarks = results.multiHandLandmarks[i];
                        // Handedness is an array, get the first result's label
                        const handedness = results.multiHandedness[i] ? results.multiHandedness[i].label : 'Unknown';

                        this.drawLandmarks(landmarks); // Landmarks are drawn on non-mirrored canvas space
                        this.calculateAndOutputAngles(landmarks, handedness, i);
                    }
                }
                this.updateStatus();
            }

            drawLandmarks(landmarks) {
                // Draw connections (MediaPipe's HAND_CONNECTIONS can be used if drawing_utils is loaded)
                // For now, using the custom connections array.
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], // Thumb (THUMB_CMC to THUMB_TIP)
                    [0, 5], [5, 6], [6, 7], [7, 8], // Index (WRIST to INDEX_FINGER_TIP)
                    [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                    [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                    [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
                    [5, 9], [9, 13], [13, 17] // Palm connections
                ];

                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)'; // Green lines
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                for (const connection of connections) {
                    const startLandmark = landmarks[connection[0]];
                    const endLandmark = landmarks[connection[1]];
                    if (startLandmark && endLandmark) {
                         // Scale landmarks to canvas dimensions
                        this.ctx.moveTo(startLandmark.x * this.canvas.width, startLandmark.y * this.canvas.height);
                        this.ctx.lineTo(endLandmark.x * this.canvas.width, endLandmark.y * this.canvas.height);
                    }
                }
                this.ctx.stroke();

                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; // Red dots
                for (let j = 0; j < landmarks.length; j++) {
                    const landmark = landmarks[j];
                    if (landmark) {
                        this.ctx.beginPath();
                        this.ctx.arc(landmark.x * this.canvas.width, landmark.y * this.canvas.height, 5, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                }
            }

            calculateVector(p1, p2) {
                return { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };
            }

            dotProduct(v1, v2) {
                return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
            }

            magnitude(v) {
                return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            }

            calculateAngle(p1, p2, p3) { // Angle at p2, between vector p2p1 and p2p3
                const v1 = this.calculateVector(p2, p1); // Vector from p2 to p1
                const v2 = this.calculateVector(p2, p3); // Vector from p2 to p3

                const dot = this.dotProduct(v1, v2);
                const magV1 = this.magnitude(v1);
                const magV2 = this.magnitude(v2);

                if (magV1 === 0 || magV2 === 0) return 0; // Avoid division by zero

                const cosAngle = Math.max(-1, Math.min(1, dot / (magV1 * magV2))); // Clamp value
                const angleRad = Math.acos(cosAngle);
                return angleRad * (180 / Math.PI); // Convert to degrees
            }

            calculateAndOutputAngles(landmarks, handedness, handIndex) {
                const updateRate = parseInt(document.getElementById('updateRate').value) || 100;
                const angleThreshold = parseFloat(document.getElementById('angleThreshold').value) || 5.0;
                const enableIK = document.getElementById('enableIK').checked;

                const now = Date.now();
                if (this.lastUpdateTime && (now - this.lastUpdateTime) < updateRate) {
                    return;
                }
                // For per-hand update time:
                // if (this.lastUpdateTime && this.lastUpdateTime[handKey] && (now - this.lastUpdateTime[handKey]) < updateRate) return;
                // this.lastUpdateTime[handKey] = now;
                this.lastUpdateTime = now; // Global update time for now

                const handKey = `${handedness}_${handIndex}`; // Unique key per hand
                if (!this.lastAngles[handKey]) this.lastAngles[handKey] = {};

                const currentAngles = {};

                // Define finger joints using landmark indices from MediaPipe
                // Each sub-array is [point1, middle_point, point2] for angle calculation at middle_point
                const jointDefinitions = {
                    // Thumb (more complex, often needs specific handling)
                    'THUMB_CMC_MCP': [this.LANDMARK_NAMES.indexOf('WRIST'), this.LANDMARK_NAMES.indexOf('THUMB_CMC'), this.LANDMARK_NAMES.indexOf('THUMB_MCP')],
                    'THUMB_MCP_IP': [this.LANDMARK_NAMES.indexOf('THUMB_CMC'), this.LANDMARK_NAMES.indexOf('THUMB_MCP'), this.LANDMARK_NAMES.indexOf('THUMB_IP')],
                    'THUMB_IP_TIP': [this.LANDMARK_NAMES.indexOf('THUMB_MCP'), this.LANDMARK_NAMES.indexOf('THUMB_IP'), this.LANDMARK_NAMES.indexOf('THUMB_TIP')],

                    // Index Finger
                    'INDEX_MCP_PIP': [this.LANDMARK_NAMES.indexOf('INDEX_FINGER_MCP'), this.LANDMARK_NAMES.indexOf('INDEX_FINGER_PIP'), this.LANDMARK_NAMES.indexOf('INDEX_FINGER_DIP')], // Angle at PIP
                    'INDEX_PIP_DIP': [this.LANDMARK_NAMES.indexOf('INDEX_FINGER_PIP'), this.LANDMARK_NAMES.indexOf('INDEX_FINGER_DIP'), this.LANDMARK_NAMES.indexOf('INDEX_FINGER_TIP')], // Angle at DIP
                     // Angle of MCP relative to wrist/palm (approximation)
                    'INDEX_WRIST_MCP': [this.LANDMARK_NAMES.indexOf('WRIST'),this.LANDMARK_NAMES.indexOf('INDEX_FINGER_MCP'), this.LANDMARK_NAMES.indexOf('INDEX_FINGER_PIP')],


                    // Middle Finger
                    'MIDDLE_MCP_PIP': [this.LANDMARK_NAMES.indexOf('MIDDLE_FINGER_MCP'), this.LANDMARK_NAMES.indexOf('MIDDLE_FINGER_PIP'), this.LANDMARK_NAMES.indexOf('MIDDLE_FINGER_DIP')],
                    'MIDDLE_PIP_DIP': [this.LANDMARK_NAMES.indexOf('MIDDLE_FINGER_PIP'), this.LANDMARK_NAMES.indexOf('MIDDLE_FINGER_DIP'), this.LANDMARK_NAMES.indexOf('MIDDLE_FINGER_TIP')],
                    'MIDDLE_WRIST_MCP': [this.LANDMARK_NAMES.indexOf('WRIST'),this.LANDMARK_NAMES.indexOf('MIDDLE_FINGER_MCP'), this.LANDMARK_NAMES.indexOf('MIDDLE_FINGER_PIP')],


                    // Ring Finger
                    'RING_MCP_PIP': [this.LANDMARK_NAMES.indexOf('RING_FINGER_MCP'), this.LANDMARK_NAMES.indexOf('RING_FINGER_PIP'), this.LANDMARK_NAMES.indexOf('RING_FINGER_DIP')],
                    'RING_PIP_DIP': [this.LANDMARK_NAMES.indexOf('RING_FINGER_PIP'), this.LANDMARK_NAMES.indexOf('RING_FINGER_DIP'), this.LANDMARK_NAMES.indexOf('RING_FINGER_TIP')],
                    'RING_WRIST_MCP': [this.LANDMARK_NAMES.indexOf('WRIST'),this.LANDMARK_NAMES.indexOf('RING_FINGER_MCP'), this.LANDMARK_NAMES.indexOf('RING_FINGER_PIP')],

                    // Pinky Finger
                    'PINKY_MCP_PIP': [this.LANDMARK_NAMES.indexOf('PINKY_MCP'), this.LANDMARK_NAMES.indexOf('PINKY_PIP'), this.LANDMARK_NAMES.indexOf('PINKY_DIP')],
                    'PINKY_PIP_DIP': [this.LANDMARK_NAMES.indexOf('PINKY_PIP'), this.LANDMARK_NAMES.indexOf('PINKY_DIP'), this.LANDMARK_NAMES.indexOf('PINKY_TIP')],
                    'PINKY_WRIST_MCP': [this.LANDMARK_NAMES.indexOf('WRIST'),this.LANDMARK_NAMES.indexOf('PINKY_MCP'), this.LANDMARK_NAMES.indexOf('PINKY_PIP')],
                };

                // Calculate wrist orientation (simplified - angle of palm relative to horizontal)
                // A more robust wrist orientation would involve comparing wrist-to-MCP vectors against a reference.
                const p0 = landmarks[this.LANDMARK_NAMES.indexOf('WRIST')];
                const p9 = landmarks[this.LANDMARK_NAMES.indexOf('MIDDLE_FINGER_MCP')]; // Middle finger MCP as a reference for palm direction
                if (p0 && p9) {
                    currentAngles['WRIST_ROLL'] = Math.atan2(p9.y - p0.y, p9.x - p0.x) * (180 / Math.PI); // Roll around Z-axis (view axis)
                     // Simple pitch: angle of wrist-MCP vector with XY plane (assuming Z is depth)
                    const palmVector = this.calculateVector(p0, p9);
                    currentAngles['WRIST_PITCH'] = Math.atan2(palmVector.z, Math.sqrt(palmVector.x**2 + palmVector.y**2)) * (180 / Math.PI);

                }

                for (const [jointName, points] of Object.entries(jointDefinitions)) {
                    const p1 = landmarks[points[0]];
                    const p2 = landmarks[points[1]]; // Angle is at this point
                    const p3 = landmarks[points[2]];

                    if (p1 && p2 && p3) {
                        currentAngles[jointName] = this.calculateAngle(p1, p2, p3);
                    } else {
                        currentAngles[jointName] = 0; // Default if landmarks missing
                    }
                }

                let hasSignificantChange = false;
                for (const [jointName, angle] of Object.entries(currentAngles)) {
                    const lastAngleVal = this.lastAngles[handKey][jointName] || 0;
                    if (Math.abs(angle - lastAngleVal) > angleThreshold) {
                        hasSignificantChange = true;
                        this.lastAngles[handKey][jointName] = angle;
                    }
                }

                if (hasSignificantChange) {
                    this.printToTerminal(`\n# ${handedness} Hand #${handIndex + 1} @ ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3})}`);

                    for (const [jointName, angle] of Object.entries(currentAngles)) {
                        if (angle !== undefined) { // Only print if calculated
                           this.printToTerminal(`${jointName}: ${angle.toFixed(1)}°`);
                        }
                    }

                    if (enableIK) {
                        this.generateIKCommands(currentAngles, landmarks, handedness, handIndex);
                    }
                    this.printToTerminal('---');
                }
            }

            generateIKCommands(angles, landmarks, handedness, handIndex) {
                this.printToTerminal('\n## IK Commands:');
                const prefix = handedness.substring(0,1); // L or R

                // Example: Wrist Roll & Pitch (using the simplified calculations)
                if (angles['WRIST_ROLL'] !== undefined) this.printToTerminal(`ROBOT_CMD ${prefix}_WRIST_ROLL ${angles['WRIST_ROLL'].toFixed(1)}`);
                if (angles['WRIST_PITCH'] !== undefined) this.printToTerminal(`ROBOT_CMD ${prefix}_WRIST_PITCH ${angles['WRIST_PITCH'].toFixed(1)}`);

                // Example: Index Finger MCP and PIP flexion
                if (angles['INDEX_WRIST_MCP'] !== undefined) this.printToTerminal(`ROBOT_CMD ${prefix}_INDEX_MCP_FLEX ${angles['INDEX_WRIST_MCP'].toFixed(1)}`);
                if (angles['INDEX_MCP_PIP'] !== undefined) this.printToTerminal(`ROBOT_CMD ${prefix}_INDEX_PIP_FLEX ${angles['INDEX_MCP_PIP'].toFixed(1)}`);

                // Example: Thumb MCP flexion
                if (angles['THUMB_CMC_MCP'] !== undefined) this.printToTerminal(`ROBOT_CMD ${prefix}_THUMB_CMC_FLEX ${angles['THUMB_CMC_MCP'].toFixed(1)}`);
                if (angles['THUMB_MCP_IP'] !== undefined) this.printToTerminal(`ROBOT_CMD ${prefix}_THUMB_MCP_FLEX ${angles['THUMB_MCP_IP'].toFixed(1)}`);

                // Example: Gripper state based on distance between thumb tip and index finger tip
                const thumbTip = landmarks[this.LANDMARK_NAMES.indexOf('THUMB_TIP')];
                const indexTip = landmarks[this.LANDMARK_NAMES.indexOf('INDEX_FINGER_TIP')];
                if (thumbTip && indexTip) {
                    const distVector = this.calculateVector(thumbTip, indexTip);
                    const distance = this.magnitude(distVector); // This distance is in normalized screen coordinates
                    // Heuristic: if distance is small, gripper is closed. Scale might need adjustment.
                    const gripperThreshold = 0.05; // Needs tuning
                    const gripperState = distance < gripperThreshold ? "CLOSED" : "OPEN";
                    this.printToTerminal(`ROBOT_CMD ${prefix}_GRIPPER ${gripperState} (dist: ${distance.toFixed(3)})`);
                }
            }

            printToTerminal(text) {
                const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit'});
                this.terminal.textContent += `[${timestamp}] ${text}\n`;
                this.terminal.scrollTop = this.terminal.scrollHeight; // Auto-scroll
            }

            clearTerminal() {
                this.terminal.textContent = '';
                this.printToTerminal('SYSTEM: Terminal cleared.');
            }

            updateStatus() {
                if (this.lastUpdateTime) {
                    document.getElementById('lastUpdate').textContent = new Date(this.lastUpdateTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit'});
                }
            }
        }

        // Initialize the application when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const controller = new HandIKController();
        });
    </script>
</body>
</html>
